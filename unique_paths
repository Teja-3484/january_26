#MEMORIZATION
class Solution:
     def uniquePaths(self, m: int, n: int) -> int: 
        def fun(m,n,dp): 
            if m==0 or n==0: 
                return 1 
            if dp[m][n]!=-1: 
                return dp[m][n] 
            if m>0 and n>0 :
                dp[m][n]=fun(m-1,n,dp)+fun(m,n-1,dp) 
            return dp[m][n]
        dp=[[-1]*(n) for i in range(m)] 
        return fun(m-1,n-1,dp)
#SPACE OPTIMIZATION
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        res = 1
        k = min(m-1, n-1)
        for i in range(1, k+1):
            res = res * (m+n-2 - k + i) // i
        return res
#TABULATION
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        dp = [[0]*n for i in range(m)]
        for i in range(m):
            dp[i][0] = 1
        for j in range(n):
            dp[0][j] = 1
        for i in range(1, m):
            for j in range(1, n):
                dp[i][j] = dp[i-1][j] + dp[i][j-1]
        return dp[m-1][n-1]
